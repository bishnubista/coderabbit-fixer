#!/usr/bin/env python3
from __future__ import annotations

import json
import os
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Any

STATE_FILE = Path(".coderabbit-review.json")
RED = "\033[0;31m"
GREEN = "\033[0;32m"
YELLOW = "\033[1;33m"
NC = "\033[0m"


def usage() -> None:
    print(
        "Usage:\n"
        "  cr-done <id> [id2...]\n"
        "  cr-done --last [N]\n"
        "  cr-done --no-resolve"
    )


def error_for_llm(message: str, hint: str) -> "None":
    print(f"{RED}ERROR: {message}{NC}", file=sys.stderr)
    print("", file=sys.stderr)
    print("ðŸ¤– LLM RECOVERY HINT:", file=sys.stderr)
    print(f"  {hint}", file=sys.stderr)
    raise SystemExit(1)


def load_state() -> dict[str, Any]:
    if not STATE_FILE.exists():
        error_for_llm("State file not found", "Run: cr-gather <PR_NUMBER>")
    try:
        return json.loads(STATE_FILE.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:
        error_for_llm(f"Invalid state JSON: {exc}", "Re-run: cr-gather <PR_NUMBER>")
    return {}


def write_state(state: dict[str, Any]) -> None:
    state_dir = STATE_FILE.parent
    fd, tmp_path = tempfile.mkstemp(prefix=".coderabbit-review.", suffix=".json", dir=state_dir)
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            json.dump(state, f, indent=2)
            f.write("\n")
        os.replace(tmp_path, STATE_FILE)
    finally:
        if os.path.exists(tmp_path):
            os.unlink(tmp_path)


def parse_args(argv: list[str]) -> tuple[list[str], int | None, bool]:
    ids: list[str] = []
    last_n: int | None = None
    resolve = True

    i = 0
    while i < len(argv):
        arg = argv[i]
        if arg == "--last":
            last_n = 2
            if i + 1 < len(argv) and argv[i + 1].isdigit():
                last_n = int(argv[i + 1])
                i += 2
                continue
            i += 1
            continue
        if arg == "--no-resolve":
            resolve = False
            i += 1
            continue
        if arg in ("--help", "-h"):
            usage()
            raise SystemExit(0)
        if arg.startswith("-"):
            error_for_llm(
                f"Unknown flag: {arg}",
                "Use: cr-done <id...> | cr-done --last [N] | cr-done --no-resolve",
            )
        ids.append(arg)
        i += 1

    return ids, last_n, resolve


def pending_candidates_from_state(state: dict[str, Any]) -> list[str]:
    issues = state.get("issues")
    if not isinstance(issues, list):
        return []

    by_id: dict[str, dict[str, Any]] = {}
    for issue in issues:
        if not isinstance(issue, dict):
            continue
        issue_id = issue.get("id")
        if isinstance(issue_id, str):
            by_id[issue_id] = issue

    session = state.get("session")
    shown_ids: list[str] = []
    if isinstance(session, dict) and isinstance(session.get("last_shown_ids"), list):
        shown_ids = [x for x in session["last_shown_ids"] if isinstance(x, str)]

    candidates = [sid for sid in shown_ids if by_id.get(sid, {}).get("status") == "pending"]
    if candidates:
        return candidates

    # Fallback for old state files without session info.
    pending: list[str] = []
    for issue in issues:
        if not isinstance(issue, dict):
            continue
        if issue.get("status") != "pending":
            continue
        issue_id = issue.get("id")
        if isinstance(issue_id, str):
            pending.append(issue_id)
    return pending


def resolve_thread(thread_id: str) -> bool:
    query = (
        "mutation { "
        f'resolveReviewThread(input: {{ threadId: "{thread_id}" }}) '
        "{ thread { isResolved } } "
        "}"
    )
    try:
        subprocess.run(
            ["gh", "api", "graphql", "-f", f"query={query}"],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
    except Exception:
        return False
    return True


def find_issue(issues: list[dict[str, Any]], issue_id: str) -> dict[str, Any] | None:
    for issue in issues:
        if issue.get("id") == issue_id:
            return issue
    return None


def refresh_summary(state: dict[str, Any]) -> None:
    issues = state.get("issues")
    if not isinstance(issues, list):
        issues = []

    fixed = sum(1 for i in issues if isinstance(i, dict) and i.get("status") == "fixed")
    pending = sum(1 for i in issues if isinstance(i, dict) and i.get("status") == "pending")

    summary = state.get("summary")
    if not isinstance(summary, dict):
        summary = {}
        state["summary"] = summary

    summary["fixed"] = fixed
    summary["pending"] = pending


def main(argv: list[str]) -> int:
    ids, last_n, resolve = parse_args(argv)
    state = load_state()

    issues_raw = state.get("issues")
    issues: list[dict[str, Any]] = []
    if isinstance(issues_raw, list):
        issues = [i for i in issues_raw if isinstance(i, dict)]
        state["issues"] = issues
    else:
        state["issues"] = issues

    if last_n is not None:
        if last_n < 1:
            error_for_llm(f"Invalid --last value: {last_n}", "Use: cr-done --last 2")

        candidates = pending_candidates_from_state(state)
        if not candidates:
            print(f"{YELLOW}No pending issues to mark.{NC}")
            return 0

        ids.extend(candidates[: min(last_n, len(candidates))])

    if not ids:
        error_for_llm("No issue IDs provided", "Usage: cr-done <id> or cr-done --last 2")

    resolved = 0
    for issue_id in ids:
        issue = find_issue(issues, issue_id)
        if issue is None:
            print(f"{YELLOW}Warning: ID '{issue_id}' not found, skipping{NC}")
            continue

        if issue.get("status") == "fixed":
            print(f"{YELLOW}ID '{issue_id}' already marked as fixed{NC}")
            continue

        issue["status"] = "fixed"
        print(f"{GREEN}âœ… Marked {issue_id} as fixed{NC}")

        if resolve:
            thread_id = issue.get("thread_id")
            if isinstance(thread_id, str) and thread_id and thread_id != "null":
                if resolve_thread(thread_id):
                    print(f"   {GREEN}â†³ Resolved GitHub thread{NC}")
                    resolved += 1
                else:
                    print(f"   {YELLOW}â†³ Could not resolve thread (may need write access){NC}")

    refresh_summary(state)
    write_state(state)

    total = len(issues)
    fixed = sum(1 for i in issues if i.get("status") == "fixed")
    remaining = total - fixed

    print("")
    print(f"Progress: {fixed}/{total} fixed ({remaining} remaining)")
    if resolved > 0:
        print(f"Resolved {resolved} GitHub thread(s)")

    if remaining == 0:
        print("")
        print(f"{GREEN}ðŸŽ‰ All issues fixed!{NC}")
        print("")
        print("Next: validate â†’ git add <files> â†’ commit â†’ push â†’ cr-gather (verify no new comments)")
    else:
        print("")
        print("Run 'cr-next' to see remaining issues")

    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
